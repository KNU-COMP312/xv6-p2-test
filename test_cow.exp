#!/usr/bin/env expect
# cow_test runner:
#   - Boot xv6 and run `cow_test`.
#   - Fail immediately on any "unknown sys call".
#   - Fail immediately on any line matching "…: FAIL".
#   - Track a pending label (line with ':' but no trailing OK/FAIL);
#     if the test crashes/EOF/timeout before it resolves, report that label as FAIL.
#   - Succeed only after seeing the sentinel line "== ALL COW CHECKS PASSED =="
#
# Exit codes:
#   0 — success (all tests passed)
#   1 — failure (FAIL/unknown-syscall/timeout/crash)

log_user 1
set match_max 1048576

proc quit_qemu {} {
    # Try Ctrl-a x first; if that fails, pkill as fallback.
    send -- "\001x"
    set ::timeout 5
    expect {
        eof {}
        timeout {
            catch { exec pkill -f qemu-system-riscv64 } _
        }
    }
}

# Kill any running QEMU (ignore errors)
catch { exec pkill -f qemu-system-riscv64 } _

# Build clean
set timeout 60
spawn make clean
expect eof

# Boot xv6
spawn make qemu CPUS=1

# Wait for shell
expect {
    -re {init: starting sh} {}
    timeout {
        puts "ERROR: Failed to start xv6 shell"
        exit 1
    }
}

# Prompt
expect -re {\$\s}

# Run test
send -- "cow_test\r"

# State
set pending_label ""

# Line handler
proc handle_line {line} {
    upvar pending_label pending_label

    # Unknown syscall → immediate fail
    if {[regexp {unknown sys call} $line]} {
        puts "FAIL: saw 'unknown sys call' during cow_test"
        quit_qemu
        exit 1
    }

    # Success sentinels → immediate success
    if {[regexp {^== ALL COW CHECKS PASSED ==$} $line]} {
        puts "PASS: cow_test completed successfully"
        quit_qemu
        puts "SUCCESS: All tests passed!"
        exit 0
    }

    # Explicit FAIL line → immediate fail (print its label)
    if {[regexp {^(.+):\s*FAIL$} $line -> label]} {
        puts "FAIL: $label"
        quit_qemu
        exit 1
    }

    # OK line → clear pending
    if {[regexp {^(.+):\s*OK$} $line]} {
        set pending_label ""
        return
    }

    # Label-only (no OK/FAIL yet) → remember as pending
    if {[regexp {^(.+):\s*$} $line -> lbl]} {
        set pending_label $lbl
        return
    }
    if {[string first ":" $line] >= 0 && ![regexp {:\s*(OK|FAIL)$} $line]} {
        set pending_label $line
        return
    }
}

# Main loop: read lines until success/failure/timeout/eof
set timeout 240
while {1} {
    expect {
        -re {([^\r\n]+)\r?\n} {
            set line $expect_out(1,string)
            handle_line $line
            exp_continue
        }
        -re {\$\s} {
            # Shell prompt may appear; keep reading
            exp_continue
        }
        timeout {
            if {$pending_label ne ""} {
                puts "FAIL: $pending_label (truncated before OK/FAIL)"
            } else {
                puts "ERROR: Timeout waiting for cow_test output"
            }
            quit_qemu
            exit 1
        }
        eof {
            # If success had occurred, we would have exited already
            if {$pending_label ne ""} {
                puts "FAIL: $pending_label (truncated before OK/FAIL)"
            } else {
                puts "ERROR: QEMU exited unexpectedly"
            }
            exit 1
        }
    }
}

